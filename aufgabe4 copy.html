<!DOCTYPE HTML>
<html>

<head>
	<title>GVT PK</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
</head>

<body class="is-preload">

	<!-- Wrapper -->
	<div id="wrapper">

		<!-- Main -->
		<div id="main">
			<div class="inner">

				<!-- Header -->
				<!-- <header id="header">
							</header> -->

				<!-- Banner -->
				<section id="banner">
					<div class="content">
						<header>
							<h1>Exercise 3 Farbig gefüllte 2D Geometrie<br />
								<h1>
						</header>
						<p>Bearbeitungszeit: 30 - 45 Minuten</p>
						<p>Kolorieren Sie eine eigene 2D-Geometrie indem Sie nun Dreiecke (keine Linien)
							erzeugen<br>(Sie können auf der Lösung der vorherigen Aufgabe aufbauen). Sie können dabei
							einfarbige Flächen oder auch Farbverläufe einsetzen.</p>
					</div>

				</section>
				<canvas width="554" height="756" id="my_Canvas"></canvas>
				<h1></h1>
				<p></p>
				<section>

				</section>

			</div>
		</div>

		<!-- Sidebar -->
		<div id="sidebar">
			<div class="inner">

				<!-- Menu -->
				<nav id="menu">
					<header class="major">
						<h2>Menu</h2>
					</header>
					<ul>
						<li><a href="index.html">Homepage</a></li>
						<li><a href="aufgabe1.html">Exercise 1</a></li>
						<li><a href="aufgabe2.html">Exercise 2</a></li>
						<li><a href="aufgabe3.html">Exercise 3</a></li>
						<li><a href="aufgabe4.html">Exercise 4</a></li>
						<li><a href="aufgabe5.html">Exercise 5</a></li>
					</ul>
				</nav>


				<!-- Footer -->
				<footer id="footer">
					<p class="copyright">&copy; Untitled. All rights reserved. Demo Images: <a
							href="https://unsplash.com">Unsplash</a>. </p>
				</footer>

			</div>
		</div>

	</div>

	<!-- Scripts -->

	<script>
		// Get the WebGL context.
		var canvas = document.getElementById('my_Canvas');
		var gl = canvas.getContext('experimental-webgl');

		// Set background color to white
		gl.clearColor(1, 1, 1, 1);
		// Backface culling.

		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);

		// Compile vertex shader. 
		var vsSource = '' +
			'attribute vec3 pos;' +
			'attribute vec4 col;' +
			'varying vec4 color;' +
			'void main(){' + 'color = col;' +
			'gl_Position = vec4(pos, 1);' +
			'}';
		var vs = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vs, vsSource);
		gl.compileShader(vs);

		// Compile fragment shader.
		fsSouce = 'precision mediump float;' +
			'varying vec4 color;' +
			'void main() {' +
			'gl_FragColor = color;' +
			'}';
		var fs = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fs, fsSouce);
		gl.compileShader(fs);

		// Link shader together into a program.
		var prog = gl.createProgram();
		gl.attachShader(prog, vs);
		gl.attachShader(prog, fs);
		gl.bindAttribLocation(prog, 0, "pos");
		gl.linkProgram(prog);
		gl.useProgram(prog);

		// Vertex data.
		//var 
		// Positions, index data.
		var vertices, indicesLinies, indicesTris;
		// Fill the data arrays.
		// Draw:
		createVertexDataForDraw();

		// Setup position vertex buffer object.
		var vboPos = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
		gl.bufferData(gl.ARRAY_BUFFER,
			vertices, gl.STATIC_DRAW);
		// Bind vertex buffer to attribute variable.
		var posAttrib = gl.getAttribLocation(prog, 'pos');
		gl.vertexAttribPointer(posAttrib, 3,
			gl.FLOAT, false, 28, 0);
		gl.enableVertexAttribArray(posAttrib);

		// Setup constant color.
		//3|4|5-6|2|4|5-3|5|2-5|7|8|9-0|6|3...
		var colAttrib = gl.getAttribLocation(prog, 'col');

		// Setup index buffer object for Lines
		var iboLines = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
			indicesLinies, gl.STATIC_DRAW);
		iboLines.numberOfElements = indicesLinies.length;
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

		var iboTris = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
			indicesTris, gl.STATIC_DRAW);
		iboTris.numberOfElements = indicesTris.length;
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

		// Clear framebuffer and render primitives.
		gl.clear(gl.COLOR_BUFFER_BIT);

		gl.vertexAttribPointer(colAttrib, 4,
			gl.FLOAT, false, 28, 12);
		gl.enableVertexAttribArray(colAttrib);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
		gl.drawElements(gl.TRIANGLES,
			iboTris.numberOfElements, gl.UNSIGNED_SHORT, 0);
		gl.disableVertexAttribArray(colAttrib);

		gl.vertexAttrib4f(colAttrib, 0, 0, 1, 1);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
		gl.drawElements(gl.LINES,
			iboLines.numberOfElements, gl.UNSIGNED_SHORT, 0);


		// Vertex data.
		//var 
		// Positions, index data.
		var vertices, indicesLinies, indicesTris;
		// Fill the data arrays.
		// Draw:
		createVertexDataForDraw();

		// Setup position vertex buffer object.
		var vboPos = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
		gl.bufferData(gl.ARRAY_BUFFER,
			vertices, gl.STATIC_DRAW);
		// Bind vertex buffer to attribute variable.
		var posAttrib = gl.getAttribLocation(prog, 'pos');
		gl.vertexAttribPointer(posAttrib, 3,
			gl.FLOAT, false, 28, 0);
		gl.enableVertexAttribArray(posAttrib);

		// Setup constant color.
		//3|4|5-6|2|4|5-3|5|2-5|7|8|9-0|6|3...
		var colAttrib = gl.getAttribLocation(prog, 'col');

		// Setup index buffer object for Lines
		var iboLines = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
			indicesLinies, gl.STATIC_DRAW);
		iboLines.numberOfElements = indicesLinies.length;
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

		var iboTris = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
			indicesTris, gl.STATIC_DRAW);
		iboTris.numberOfElements = indicesTris.length;
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

		// Clear framebuffer and render primitives.
		gl.clear(gl.COLOR_BUFFER_BIT);

		gl.vertexAttribPointer(colAttrib, 4,
			gl.FLOAT, false, 28, 12);
		gl.enableVertexAttribArray(colAttrib);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
		gl.drawElements(gl.TRIANGLES,
			iboTris.numberOfElements, gl.UNSIGNED_SHORT, 0);
		gl.disableVertexAttribArray(colAttrib);

		gl.vertexAttrib4f(colAttrib, 0, 0, 1, 1);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
		gl.drawElements(gl.LINES,
			iboLines.numberOfElements, gl.UNSIGNED_SHORT, 0);


		function createVertexDataForDraw() {
			//vertical lines
			var n = 9;
			//horizontal lines
			var m = 60;
			// Positions.
			var verticesCountOfOneObject = (n + 1) * (m + 1)
			vertices = new Float32Array(3 * (4 + 3) * verticesCountOfOneObject);
			// Index data for Linestrip.
			indicesLinies = new Uint16Array(2 * 3 * 2 * n * m);
			indicesTris = new Uint16Array(3 * 3 * 2 * n * m);

			//Data for the drop
			var dt = 1 * Math.PI / n; // calculates the steps size, through angle for one part of the object
			var dr = 1 / m;
			// Counter for entries in index array.
			var iIndex = 0;
			var iTris = 0;
			var dr = 2 / m;
			//Loop for drop 
			// Loop angle t.
			for (var i = 0, t = Math.PI / 17; i <= n; i++, t += dt) {

				// Loop radius r.
				for (var j = 0, r = -1; j <= m; j++, r += dr) {

					var iVertex = verticesCountOfOneObject + i * (m + 1) + j;

					// Kiss Surface
					var x = Math.pow(r, 2) * Math.sqrt((1 - r) / 1.0) * Math.cos(t) / 1.3;
					var y = 1 - (r / 1.5); // 1- to invert
					var z = Math.pow(r, 2) * Math.sqrt((1 - r) / 2.0) * Math.sin(t);


					// Set vertex positions.
					vertices[iVertex * 7] = x;
					vertices[iVertex * 7 + 1] = y;
					vertices[iVertex * 7 + 2] = z;

					// Color:
					vertices[iVertex * 7 + 3] = (y + 1.1) * t / (Math.PI * 2);
					vertices[iVertex * 7 + 4] = 0.1;
					vertices[iVertex * 7 + 5] = 1;
					vertices[iVertex * 7 + 6] = 1;

					// Set index.
					//generating the verticle lines
					if (j > 0 && i > 0) {
						indicesLinies[iIndex++] = iVertex - 1;
						indicesLinies[iIndex++] = iVertex;
					}

					// generating the horizontal lines
					if (j > 0 && i > 0) {
						indicesLinies[iIndex++] = iVertex - (m + 1);
						indicesLinies[iIndex++] = iVertex;
					}

					//generating the surfaces
					if (j > 0 && i > 0) {
						indicesTris[iTris++] = iVertex;
						indicesTris[iTris++] = iVertex - 1;
						indicesTris[iTris++] = iVertex - (m + 1);

						indicesTris[iTris++] = iVertex - 1;
						indicesTris[iTris++] = iVertex - (m + 1) - 1;
						indicesTris[iTris++] = iVertex - (m + 1);
					}
				}
			}

		}

		function createVertexDataForDraw2() {
			//vertical lines
			var n = 9;
			//horizontal lines
			var m = 60;
			// Positions.
			var verticesCountOfOneObject = (n + 1) * (m + 1)
			vertices = new Float32Array(3 * (4 + 3) * verticesCountOfOneObject);
			// Index data for Linestrip.
			indicesLinies = new Uint16Array(2 * 3 * 2 * n * m);
			indicesTris = new Uint16Array(3 * 3 * 2 * n * m);

			//Data for the drop
			var dt = 1 * Math.PI / n; // calculates the steps size, through angle for one part of the object
			var dr = 1 / m;
			// Counter for entries in index array.
			var iIndex = 0;
			var iTris = 0;
			var dr = 2 / m;
			//Loop for drop 
			// Loop angle t.
			for (var i = 0, t = Math.PI / 17; i <= n; i++, t += dt) {

				// Loop radius r.
				for (var j = 0, r = -1; j <= m; j++, r += dr) {

					var iVertex = verticesCountOfOneObject + i * (m + 1) + j;

					// Kiss Surface
					var x = Math.pow(r, 2) * Math.sqrt((1 - r) / 1.0) * Math.cos(t) / 1.3;
					var y = (r / 1.5); // 1- to invert
					var z = Math.pow(r, 2) * Math.sqrt((1 - r) / 2.0) * Math.sin(t);


					// Set vertex positions.
					vertices[iVertex * 7] = x;
					vertices[iVertex * 7 + 1] = y;
					vertices[iVertex * 7 + 2] = z;

					// Color:
					vertices[iVertex * 7 + 3] = (y + 1.1) * t / (Math.PI * 2);
					vertices[iVertex * 7 + 4] = 0.1;
					vertices[iVertex * 7 + 5] = 1;
					vertices[iVertex * 7 + 6] = 1;

					// Set index.
					//generating the verticle lines
					if (j > 0 && i > 0) {
						indicesLinies[iIndex++] = iVertex - 1;
						indicesLinies[iIndex++] = iVertex;
					}

					// generating the horizontal lines
					if (j > 0 && i > 0) {
						indicesLinies[iIndex++] = iVertex - (m + 1);
						indicesLinies[iIndex++] = iVertex;
					}

					//generating the surfaces
					if (j > 0 && i > 0) {
						indicesTris[iTris++] = iVertex;
						indicesTris[iTris++] = iVertex - 1;
						indicesTris[iTris++] = iVertex - (m + 1);

						indicesTris[iTris++] = iVertex - 1;
						indicesTris[iTris++] = iVertex - (m + 1) - 1;
						indicesTris[iTris++] = iVertex - (m + 1);
					}
				}
			}

		}
	</script>
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>

</body>

</html>